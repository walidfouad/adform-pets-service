{"version":3,"sources":["../../src/data/pets.db.js"],"names":["dbDirectory","PETSDB","data","Promise","resolve","reject","modelTypes","length","Error","result","forEach","modelType","mType","toLowerCase","modelFilePath","modelBuffer","fs","readFileSync","err","modelData","JSON","parse","concat","type","existsSync","stringify","writeFileSync","if"],"mappings":";;;;;;;;AAAA;;AACA;;;;AAEA;;;;;;;;AAEA,IAAMA,cAAc,uBAAY,WAAZ,CAApB;;IAEqBC,M;AAEjB,sBAAc;AAAA;;AACV,aAAKC,IAAL,GAAY,EAAZ;AACH;;;;mCAEU;AAAA;;AACP,mBAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC;AACA;;;AAGAD,wBAAQ,MAAKF,IAAb;AACH,aANM,CAAP;AAOH;;;oCAEW;AAAA;;AACR,mBAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC;AACA,gCAAKL,WAAL;AACA;;AAEAI,wBAAQ,OAAKF,IAAb;AACH,aANM,CAAP;AAQH;;;mCAEUI,U,EAAY;AACnB,mBAAO,IAAIH,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC,oBAAI,CAACC,UAAD,IAAeA,WAAWC,MAAX,KAAsB,CAAzC,EAA4C;AACxC,2BAAOF,OAAO,IAAIG,KAAJ,CAAU,wBAAV,CAAP,CAAP;AACH;AACD,oBAAIC,SAAS,EAAb;AACAH,2BAAWI,OAAX,CAAmB,UAACC,SAAD,EAAe;;AAE9B,wBAAMC,QAAQD,UAAUE,WAAV,EAAd;;AAEA,wBAAMC,gBAAgB,oBAASd,WAAT,EAAsBY,KAAtB,IAA+B,QAArD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAMG,cAAcC,aAAGC,YAAH,CAAgBH,aAAhB,EAA+B,UAACI,GAAD,EAAS;AACxD,4BAAIA,GAAJ,EAAS;AACLb,mCAAO,IAAIG,KAAJ,yBACmBI,KADnB,yEAItBM,GAJsB,sBAAP;AAMH;AACJ,qBATmB,CAApB;;AAWA,wBAAMC,YAAaJ,eAAeA,YAAYR,MAAZ,GAAqB,CAArC,GAA0Ca,KAAKC,KAAL,CAAWN,WAAX,CAA1C,GAAoE,IAAtF;AACAN,6BAASA,OAAOF,MAAP,KAAkB,CAAlB,GAAsBE,SAASU,SAA/B,GAA2CV,OAAOa,MAAP,CAAcH,SAAd,CAApD;AAEH,iBA1BD;;AA4BAf,wBAAQK,MAAR;AACH,aAlCM,CAAP;AAoCH;;;mCAEUU,S,EAAW;AAAA;;AAClB,mBAAO,IAAIhB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC,oBAAMM,YAAYQ,UAAUI,IAA5B;;AAEA,oBAAI,CAACZ,SAAL,EAAgB;AACZN,2BAAO,IAAIG,KAAJ,CAAU,wBAAV,CAAP;AACH;;AAED,oBAAMI,QAAQD,UAAUE,WAAV,EAAd;;AAEA,oBAAI,CAAC,OAAKX,IAAN,IAAc,CAAC,OAAKA,IAAL,CAAUU,KAAV,CAAnB,EAAqC;AACjC,2BAAOP,OAAO,IAAIG,KAAJ,gCAAuCI,KAAvC,OAAP,CAAP;AACH;;AAED,oBAAME,gBAAgB,oBAASd,WAAT,EAAsBY,KAAtB,IAA+B,OAArD;;AAEA;AACA,oBAAII,aAAGQ,UAAH,CAAcV,aAAd,CAAJ,EAAkC,CAEjC;;AAED;AACA,oBAAMK,YAAYC,KAAKK,SAAL,CAAe,OAAKvB,IAAL,CAAUU,KAAV,CAAf,CAAlB;AACAI,6BAAGU,aAAH,CAAiBZ,aAAjB,EAAgCK,SAAhC,EAA4CD,GAAD,GAAQ;AAC/CS,sBAD+C,eAC3CT,GAD2C,EACtC;AACLb,+BAAO,IAAIG,KAAJ,4BACsBI,KADtB,mEAInBM,GAJmB,oBAAP;AAMH;AAR8C,iBAAnD;;AAYAd;AACH,aAnCM,CAAP;AAoCH;;;;;;kBAvGgBH,M","file":"pets.db.js","sourcesContent":["import { mdir, projectPath, pathJoin } from '../utils/path';\r\nimport formatData from './data-format';\r\n\r\nimport fs from 'fs';\r\n\r\nconst dbDirectory = projectPath('json_data');\r\n\r\nexport default class PETSDB {\r\n\r\n    constructor() {\r\n        this.data = {};\r\n    }\r\n\r\n    readData() {\r\n        return new Promise((resolve, reject) => {\r\n            // read all json db files\r\n            // here should update data from json files \r\n\r\n\r\n            resolve(this.data);\r\n        });\r\n    }\r\n\r\n    writeData() {\r\n        return new Promise((resolve, reject) => {\r\n            // ensure db directory exists\r\n            mdir(dbDirectory);\r\n            // steps to save\r\n\r\n            resolve(this.data);\r\n        });\r\n\r\n    }\r\n\r\n    readModels(modelTypes) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!modelTypes || modelTypes.length === 0) {\r\n                return reject(new Error('No modelType provided.'));\r\n            }\r\n            let result = [];\r\n            modelTypes.forEach((modelType) => {\r\n\r\n                const mType = modelType.toLowerCase();\r\n\r\n                const modelFilePath = pathJoin(dbDirectory, mType) + '.3json';\r\n\r\n                // check if model file already exists\r\n                // if (!fs.existsSync(modelFilePath)) {\r\n                //     return reject(new Error(`No data found for Model ${mType}.`));\r\n                // }\r\n\r\n                // here read model file from json db directory\r\n                const modelBuffer = fs.readFileSync(modelFilePath, (err) => {\r\n                    if (err) {\r\n                        reject(new Error(\r\n                            `Error reading model${mType}.\r\n\t\t\t\t\t\t\tError details =>\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t${err}\r\n\t\t\t\t\t\t\t`));\r\n                    }\r\n                });\r\n\r\n                const modelData = (modelBuffer && modelBuffer.length > 0) ? JSON.parse(modelBuffer) : null;\r\n                result = result.length === 0 ? result = modelData : result.concat(modelData);\r\n\r\n            });\r\n\r\n            resolve(result);\r\n        });\r\n\r\n    }\r\n\r\n    writeModel(modelData) {\r\n        return new Promise((resolve, reject) => {\r\n            const modelType = modelData.type;\r\n\r\n            if (!modelType) {\r\n                reject(new Error('No modelType provided.'));\r\n            }\r\n\r\n            const mType = modelType.toLowerCase();\r\n\r\n            if (!this.data || !this.data[mType]) {\r\n                return reject(new Error(`No provided data for model${mType}.`));\r\n            }\r\n\r\n            const modelFilePath = pathJoin(dbDirectory, mType) + '.json';\r\n\r\n            // check if model file already exists\r\n            if (fs.existsSync(modelFilePath)) {\r\n\r\n            }\r\n\r\n            // here write to model file in json db directory\r\n            const modelData = JSON.stringify(this.data[mType]);\r\n            fs.writeFileSync(modelFilePath, modelData, (err) = {\r\n                if (err) {\r\n                    reject(new Error(\r\n                        `Error writing to model${mType}.\r\n\t\t\t\t\t\tError details =>\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t${err}\r\n\t\t\t\t\t\t`));\r\n                }\r\n\r\n            });\r\n\r\n            resolve();\r\n        });\r\n    }\r\n}"]}