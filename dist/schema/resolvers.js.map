{"version":3,"sources":["../../src/schema/resolvers.js"],"names":["db","DBManager","resolvers","Pet","__resolveType","pet","context","info","type","Query","getOwners","root","args","Promise","resolve","reject","readModels","then","owners","ownerWithPets","forEach","owner","pets","ownerPets","id","push","catch","err","getPets","petsWithOwners","getOwner","ownerId","getOwnerPets","readSpecificModel","Mutation","addPet","input","_","find","Error","getPet","createNewModel","model","updatePet","petId","dogs","getDogs","dog","cats","getCats","cat","updateModel","addOwner","getOwnerByEmail","email"],"mappings":"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","file":"resolvers.js","sourcesContent":["import _ from 'lodash';\r\nimport DBManager from '../data/dbmanager';\r\n\r\nconst db = new DBManager();\r\n\r\n/**\r\n * Set of Resolvers with implementations for Schema queries and mutations\r\n */\r\nconst resolvers = {\r\n    Pet: {\r\n        // this is added to resolve interface issue (decide which child type to resolve)\r\n        __resolveType(pet, context, info) {\r\n            if (pet.type === 'CAT') {\r\n                return 'Cat';\r\n            }\r\n\r\n            if (pet.type === 'DOG') {\r\n                return 'Dog';\r\n            }\r\n\r\n            return null;\r\n        }\r\n    },\r\n    Query: {\r\n        /**\r\n         * Get all owners and fill pets data fields for each\r\n         */\r\n        getOwners: (root, args, context, info) => {\r\n            return new Promise((resolve, reject) => {\r\n                db.readModels(['OWNER'])\r\n                    .then((owners) => {\r\n\r\n                        let ownerWithPets = [];\r\n                        owners.forEach(owner => {\r\n                            // filling Owner pets \r\n                            owner.pets = db.ownerPets(owner.id);\r\n                            ownerWithPets.push(owner);\r\n                        });\r\n\r\n                        resolve(ownerWithPets);\r\n                    }).catch((err) => {\r\n                        reject(err);\r\n                    });\r\n            });\r\n        },\r\n        /**\r\n         * Gets Pets data fields along with the corresponding owner to each Pet\r\n         */\r\n        getPets: (root, args, context, info) => {\r\n            return new Promise((resolve, reject) => {\r\n                // as pets divided into two types/classes, and send array of model types to get all pets\r\n                db.readModels(['DOG', 'CAT'])\r\n                    .then((pets) => {\r\n                        let petsWithOwners = [];\r\n                        pets.forEach(pet => {\r\n                            // fill owner data for each pet\r\n                            pet.owner = db.getOwner(pet.ownerId);\r\n                            petsWithOwners.push(pet);\r\n                        });\r\n\r\n                        resolve(petsWithOwners);\r\n                    }).catch((err) => {\r\n                        reject(err);\r\n                    });\r\n            });\r\n        },\r\n        /**\r\n         * Get Owner data fields along with Pets assigned to him\r\n         */\r\n        getOwnerPets: (root, { ownerId }, context, info) => {\r\n            return new Promise((resolve, reject) => {\r\n                // get owner and then update its pets\r\n                db.readSpecificModel(ownerId, 'OWNER')\r\n                    .then((owner) => {\r\n                        // update owner pets. Please note owner.pets already empty, as it is not stored in db.\r\n                        owner.pets = db.ownerPets(ownerId);\r\n                        resolve(owner);\r\n\r\n                    }).catch((err) => {\r\n                        reject(err);\r\n                    });\r\n            });\r\n        }\r\n    },\r\n    Mutation: {\r\n        /**\r\n         * Adding new Pet\r\n         */\r\n        addPet: (root, { input }, context, info) => {\r\n            return new Promise((resolve, reject) => {\r\n                // checking if owner id provided, we should verify its existance in Owners collection/table\r\n                if (input.ownerId) {\r\n                    const owners = db.getOwners();\r\n                    const owner = _.find(owners, { id: input.ownerId });\r\n                    if (!owner) {\r\n                        return reject(new Error('Owner Id does not exist'));\r\n                    }\r\n                }\r\n\r\n                const pet = db.getPet(input);\r\n                if (pet) {\r\n                    return reject('Pet data fields you entered already exists.');\r\n                }\r\n\r\n                // create new pet\r\n                db.createNewModel(input)\r\n                    .then((model) => {\r\n                        // return a success message of type String [according to return type defined in typeDefs]\r\n                        resolve('New Pet has been created successfully');\r\n                    }).catch((err) => {\r\n                        reject(err);\r\n                    });\r\n            });\r\n        },\r\n        /**\r\n         * Updating Pet (by specifiying pet id)\r\n         */\r\n        updatePet: (root, {\r\n            petId,\r\n            input\r\n        }) => {\r\n            return new Promise((resolve, reject) => {\r\n                // if owner id provided, we should verify its existance in owner collection/table\r\n                if (input.ownerId) {\r\n                    const owners = db.getOwners();\r\n                    const owner = _.find(owners, { id: input.ownerId });\r\n                    if (!owner) {\r\n                        return reject(new Error('Owner Id does not exist'));\r\n                    }\r\n                }\r\n\r\n                // we need to verify that provided petId exists in pets tables (dogs and cats)\r\n                const dogs = db.getDogs();\r\n                const dog = _.find(dogs, { id: petId });\r\n\r\n                const cats = db.getCats();\r\n                const cat = _.find(cats, { id: petId });\r\n\r\n                if (!dog && !cat) {\r\n                    return reject(new Error('Pet Id does not exist'));\r\n                }\r\n\r\n                input.type = dog ? 'DOG' : 'CAT';\r\n\r\n                // go update the model (i.e. either dog or cat model) depending on type detected\r\n                db.updateModel(petId, input)\r\n                    .then((model) => {\r\n                        // return a pet model\r\n                        resolve(model);\r\n                    }).catch((err) => {\r\n                        reject(err);\r\n                    });\r\n            });\r\n        },\r\n        /**\r\n         * Adding new Owner\r\n         */\r\n        addOwner: (root, { input }, context, info) => {\r\n            return new Promise((resolve, reject) => {\r\n                input.type = 'OWNER';\r\n                const owner = db.getOwnerByEmail(input.email);\r\n                // i am considering here email should be unique\r\n                // TODO: find a way through graphql schema [it would be better]\r\n                if (owner) {\r\n                    return reject('Owner email already exists. Please choose different email address');\r\n                }\r\n\r\n                db.createNewModel(input)\r\n                    .then((model) => {\r\n                        // return a success message of type String [according to return type defined in typeDefs]\r\n                        resolve('New Owner has been created successfully');\r\n                    }).catch((err) => {\r\n                        reject(err);\r\n                    });\r\n            });\r\n        },\r\n    }\r\n};\r\n\r\nexport default resolvers;"]}